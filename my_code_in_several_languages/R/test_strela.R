


#удаление всех переменных
rm(dd,ddd,k,maxx,mm,rebro,rebro2,alef,dann,error,error2,i,j,mass,mass2,mmpro,mmpro2,mz,proizv3,rpro3,mmm)
rm(ii,kol_neir,kol_reb,kol_ver,len,ll,str,neir_str,reb,zn_r,kol_step,k_step,a,alef2,rebro3,error3,mass3,mmpro3)
rm(nastr,neir,proizv,proizv2,razn_iz,razn_must,rpro,rpro2,summm,summr,vect_m,vect_r,sigma,vx,vix,step,mmv,zz)
rm(dd_all,dd_new,minn,nnn,prog,progn,prog_ogr,dd_prog,z,mm_old,iz_old,kmm_old,neir_old,neir_,r)
rm(kk,kk2,m,m2,mx,mx2,r2,all_time,b_err,neir2,neir3,tm,tm_beg,z_step)
rm(d,M,Mp,Mq2,Mqй,Mqr,Mqrr,Mq,t)

rm(db,dd_all,dd_prog,progn,alef,dirName,dn_k,error,fr,fr_n,k_f,list_c,list_f,sigma,zz)
rm(modelBinaries,modelDescriptions,modelIds)

rm(by,by_,dann_,dann_2,dann_h,df1,df2,dh,dh_,dh2,sm,sm_,smm,tmp,un,un_,unn,unn_,sm_napr,dn_,dh_1,dann_1)  
rm(dann,dd,ddd,before,by_day,dann.Date,dann_.Date,dt,hist,i,ii,k,k_x,l,max_date,sm_Napr,plus_napr,xx,dn)  

rm(pData_,mr,mr_,mr2,extdb,mData,mData_,mt2,pData,result,result_,seldb,wData,rezult__,v,seat)
rm(dbName,dbPath,extdbName,mData.list,rbefore,cnames,dates,dList,h,lastDate,length,plus_napr)
rm(tp,tr,trains,types,extractor,viborka,init_dann_frame,dt_,dop,bad_dist,bad_k)

rm(dd_all,maxx,mm,mm_,dn_k,iz_old,j,len,dd_prog,progn,zz,alef,error,type,sigma,dann,ddd,dn,k,dann_)
rm(dh,dh_,dh2,sm,sm_,by,by_,i,max_date,min_date,ddd_,dann_.Date,l,m,xx,rr,perebor,ssozd)

rm(dannie1,mar,matrix,rawdb,rawdb_m,rawdb_p,rawdb1,rawdb2,rawdb3,tmp,tmp_m,tmp_p,date,dbName)
rm(dt,i,name_mar,p,pp,rst,sto_,stn_,tmo_,tmp_,tr,train,zz,ff,h,hh,f,z,max_dat,max_dats,dann,ufilter,)
rm(aggrdb,aggrdb_,aggrdb_mar,info,matrix_mar,new_data,new.data,new.files,pass,dbPath,kol_zap)
rm(file,filePath,files,first,format,mm,path,aggregator,filter,init_dann_frame,updater,new,new_)
rm(mar_,mar_2,mar_dt,mar_na,matr,matrix_,raw,rez,rez1,rez2,tmp1,tmp2,by,by1,by2,mar_pzd,testDF,xx)
rm(dd_all,maxx,mm_old,iz_old,j,kmm_old,len,str,yy,dat,dat_,year,yy_,err1,err2,dats,prazd,m1,max_d,min_d)

rm(neir_h,neir_hist,neir_hist_,neir_s,neir_sokr,neir2_s,sozd,id,list,neir_hist_sokr,neir_pack,neir1)
rm(neir_progn,neir_progn_old,idd,idd_,by_time,neir_progn_,progn_p,bd,pn,Type_,fby1,fby2,dd_prog_,nn,nn_,infoPath)
rm(names,fvh,kol_h,list_days,svh,vh,vh_,vh_i,nh,pack,pr,vozm,bef_end,id_ord,mt,prg,zz_,progn_,days)
rm(blok,blok_len,neir_hist_blok,cl,cores,kol_blok,neir_block,neir_blok,neirs,neirs_,clust,neir_hist_s)
rm(list_id,max_id,skor,skors,befores,mprogn,mzz,names_dat,nm,zd,bg,day_f,stroka,neir_hist_s_,nr,l_k)
rm(list_k,mon,mons,ord,pack_,marshr,rst_o,rst_n,max_rst,kol_mest,mesta,kp,max_n,cena,stoim,mrst,sel)
rm(df,vibor,coef,columns,kol,pole,ps,rows,s,spis,x.0,y,y1,y2,fun1,fun2,fun3,sh,sh_,shema,ns,k_povtor,Train,vhod)  
rm(sozd_,szd,pts,zn,zzn,progn_new,progn_new_,progn_z,prov,prov_,prover,min_pr,max_dt,prognoz_itogi)
rm(prognoz_itogi_old,prognoz_itogi_sr,srok,vid,dann2,pas,vag,kol_m,b,progn_itog,progn_itog_,shema_)
rm(best,neir_hist_s_2,neir_hist_s2,best,max_pr,best_,bad,years,ye,info_,min_dat,max_dat_pr,old_rez,names2)
rm(rezult,rezult_,rez_,pd,pd_,arenda,rezz,nm2,summir,rezult_s,tip,tip_n,tipp,nm_,str_,tip_all)
rm(pars,rez_dann,tab,tip_prog,params,tip_isp,c,vib,bef,sklei,min_before,max_vhod,max_before,max,Date)
rm(tip_name,pro,vhod_,vibor_,kol_vhod,umn_param,rr_,bef_otp,kx,new_ver,new_vid,pred,vhod_before)
rm(maxx_,mx_,kurs,tip_name_,rz,nom,popitka,itog,col,activ,x,select,stb,dann_tip,mtip,progn_p_,made,tmbeg)
rm(plus,neir_hist_1,vb,vb_,neir_hist_p,min_,max_,func,hist_,x1,x2,n,reb_,reb2,rebb,ispr,rezz_,sver)
rm(dann_hran,hran,tips,max_vh,nam,vhod_zn,hr,min_bef,rez_nn,rez_ss,ta,neir_progn_new,by_core,kpd)
rm(set_id,t_nastr,t_nastr2,dnn,xx_,progn_nm,prognozi,id_,iz,dna,uu,dn1,delet,ostavl,tp_,id_str,nnm)

rm(cc_,cc,cen,cn,st,vir,k2,tn,kol_v,razmnog,dd_,summs,ograns,ogran,ogr1,ogr2,xp,xz,text,kol_mar,kol_rez)
rm(stat,vv,id_params,time_rab,del,prognoz_itogi_,prognoz_itogi_s,tps,raw_bad,rawdb_,stan,she,marb)
rm(tmp_2,tmp_r,tt,marb2,o,k1,pDate,cena_,mesta_,mesta_2,kd1,kd2,result_1,result_2,result_3,kd,res,pData_ish)
rm(mData_ish,fm,pdat,qq,qq_n,ff_new,col_,result1,old_rez1,str_o,str_osn,str_dop,str_par,rezult1,str_delet,u)
rm(str_dop2,pass_,rz_2,ind,inf,wData_old,rezult_diff,rezult_intersect,rezult_m,rezult1_s,rezult1_m)
rm(matrix_2,mat,mat1,mat2,mb,mmb,dann0,zzz,str_2,pi,prr,neir_stat,neir_stat_new,neir_copy,stat_)
rm(na,na_,na_rz,na_rz_,wd,pzd,rz1,wData_,min_date2,rz_,na_s,na1,stat_2,tip_,tip_2,tip_ish,progn_stat)
rm(pas_,rez_cen,rez_kp,rez_st,rez_s,st_,tab_,ff_cen,ff_zn,kp_,vcd_rus,vc,vcd,vcd_,kl,kpp,skp)
rm(kp_2,maxc,minc)
   
#rm(myPackage,neural)

#   rm(dannie)


###############################################################################
#НАПОЛНЕНИЕ ИСХОДНЫМИ ДАННЫМИ


name='strela'

name='sahalin'

#ПАССАЖИРЫ запуск сбора данных. по фильтру Сахалин - месячные данные
myPackage$trs.pData.aggregate(name)
#ВАГОНЫ сбора данных. по фильтру Сахалин - месячные данные
myPackage$trs.wData.aggregate(name)


#Наработка данных склеенных таблиц
#system.time(myPackage$trs.tData.extract2(name))



#ПАССАЖИРЫ  апдейт суточными данными
myPackage$trs.pData.update(name);
#ВАГОНЫ добавка посуточных данных. по фильтру Сахалин 
myPackage$trs.wData.update(name)



#  info=myPackage$trs.dann_load('info','rez') # ЧТО БЫЛО ПРОЧИТАНО РАНЬШЕ?
#  info[(info$Database==name),'ext']=NA
#  myPackage$trs.Data_save(info, 'info','rez',TRUE)


#Наработка данных склеенных таблиц
system.time(myPackage$trs.tData.extract2(name))


#ИНФОРМАЦИЯ О ФАЙЛАХ
info=myPackage$trs.dann_load('info','rez')









#ВЫБОРКА ДАННЫХ ДЛЯ МОЕЙ НЕЙРОСЕТИ
#sozd=data.frame(name='sahalin',before=10,bef_end=10,plus_napr="0",hist='0',by_day=5,
                #Type="К",Skor="",Napr="",First="",Train="",vhod='pkm,Seats',progn='kol_mest',
                #bad_dist=30,bad_k=10,day_f='week,prazd');



#################################
#подготовлены данные для случайной выборки


name='strela'
#    dannie=myPackage$trs.dannie_for_neir(name)

min_before=10
#создание случайной нейросети. с ограничением по числу входов и миним запаздыванию
#             max_vhod=3;min_before=10
neir=myPackage$trs.sozd_neir(dannie,max_vhod=2,min_before,ogran='-')
neir$k$kol_neir=3 #увеличение объёма нейросети - сколько внутренних нейронов


#по номеру нейросети возвращает из памяти саму нейросеть
     neir=neural$get_neir_id(31)

#собственно подготовка данных, пока без оптимизации процесса подготовки
itog=myPackage$trs.sozd_neir_dann(dannie,neir);dann=itog$dann;neir=itog$neir;rm(itog)

#нормированние и массивы по новому, и инициализация всех параметров нейросети по необходимости
dann_n=neural$normir_dann(neir,dann);
neir=dann_n$neir;ddd=dann_n$dd;dd_all=dann_n$dd_all;rm(dann_n);

#    neir$sozd$vhod

# rebro=neir$rebro;rebro[((rebro[,1]==-1)&(rebro[,3]==1)),3]=2;neir$rebro=rebro;

  
  #настройка нейросети
  #system.time(nastr<-   neural$neir_nastr(ddd,neir,10))
  system.time(neir<-neural$neir_nastr_new(ddd,neir,60))
  sigma=neir$k$sigma;
  #  neir$k$ogr_k=0.2
  
  progn=neural$neir_prognoz(dd_all,neir);dd_prog=dd_all;dd_prog$z=progn$z;dd_prog$zp=progn$zp;
  #dd_prog=subset(dd_prog, select = c(Train,Date,Type,Seats,y,z,zp));
  #подсчёт итоговых отличий, независимой сверкой
  zz=aggregate(x =list(err= (dd_prog$y-dd_prog$z)**2,col=1),by = list(dd_prog$dann,dd_prog$Train), FUN = "sum")
  zz$sigma=(zz$err/zz$col)**0.5; #получилось хорошо - совпадает!
  #график коррелляции 
  plot (x=dd_prog$y,y=dd_prog$z,col=dd_prog$dann)
  
  
  #запись нейросети в базу истории нейросети, и полную и сокращённую
  neir=neural$neir.save_to_hist(neir,NULL);#запись без прогнозов - не ставит глухую активность!
  
  neir=neural$neir.save_to_hist(neir,dd_all);#запись с прогнозами
  
#    neir$sozd$vhod   ; neir$sozd$vibor ;  neir$rebro
#  neir$rebro[1:12,3]=0;neir$rebro[1,3]=1;neir$rebro[12,3]=-0.5;
#  neir$rebro[38,3]=neir$rebro[38,3]-1
  
neir$rebro
  neir$rebro[31,3]    =-0.1
#     ta=dannie$tip_all
  
#####################################################################################
  
  #поиск нужного номера
  neir_hist_s=myPackage$trs.dann_load('neiroset','sokr') #чтение списка всех нейросетей
  neir_hist_s=neir_hist_s[(neir_hist_s$activ==1),] #подвыборка активных
  
  #ГЛАВНОЕ - АНАЛИЗ ПРОГНОЗОВ. ТАБЛИЦА ИТОГОВЫХ ПРОГНОЗОВ - ПО НОВОМУ
  #     prover=c(30,50,100);     name='sahalin'
  prognoz_itogi=neural$prognoz_itogi_new(name,prover=c(30,50,100))
  
  #ДООБУЧЕНИЕ ВСЕХ НЕЙРОСЕТЕЙ многократно
  vibor=data.frame(name='strela')
  neural$all_neir_new_podnastr_many(dannie,60,vibor,2,razmnog=FALSE) 
  
  
  #ДООБУЧЕНИЕ ВСЕХ НЕЙРОСЕТЕЙ - В ПАРАЛЛЕЛЬНОМ РЕЖИМЕ
  vibor=data.frame(name='strela')
  neural$all_neir_new_podnastr_parallel(dannie,60,vibor,1,razmnog=FALSE) 
  
  
  
#####################################################################################  
#постановка нужных мне входов
  
  
  
kol_neir=2;zz=10
  
for (kol_neir in 0:3){
  for (zz in 8:12){
    
  #создание случайной нейросети. с ограничением по числу входов и миним запаздыванию
  #             max_vhod=3;min_before=10
  min_before=10
  ogran=list(o2='Seats',o1='0')
  #ogran='-'
  neir=myPackage$trs.sozd_neir(dannie,max_vhod=2,min_before,ogran)
  neir$k$kol_neir=kol_neir #увеличение объёма нейросети - сколько внутренних нейронов
  
  
vhod=neir$sozd$vhod;vibor=neir$sozd$vibor;

#kol_v=max(vhod$vhod)
kol_v=nrow(vhod[(vhod$vid=='x'),]);
maxx=zz;  #maxx=44;
vh=vhod[(vhod$vid=='y'),];vib=vibor[(vibor$vhod==0),]
vh$name='cena';vh$vid='x'
for (i in 1:maxx)
  {kol_v=kol_v+1;vh$bef_otp=i;vh$vhod=kol_v;vhod=rbind(vhod,vh)
  vib$vhod=kol_v;vibor=rbind(vibor,vib)}
vh$name='kp'
for (i in zz:maxx)
  {kol_v=kol_v+1;vh$bef_otp=i;vh$vhod=kol_v;vhod=rbind(vhod,vh)
  vib$vhod=kol_v;vibor=rbind(vibor,vib)}

vh$name='stoim';kol_v=kol_v+1;
vh$bef_otp=zz;vh$vhod=kol_v;vhod=rbind(vhod,vh)
vib$vhod=kol_v;vibor=rbind(vibor,vib)

#массив
#kol_v=kol_v+1;
  mm=min(vhod[(vhod$vid=='m'),'vhod'])
  vhod[(vhod$vid=='m'),'vhod']=kol_v-mm+1+vhod[(vhod$vid=='m'),'vhod'];
  vibor[(is.na(vibor$Train)),'vhod']=kol_v-mm+1+vibor[(is.na(vibor$Train)),'vhod']
kol_v=max(vhod$vhod)

#массив недели
#vh=vhod[((vhod$vid=='m')&(!is.na(vhod$before))),];vh=vh[1,]
#vib=vibor[(vibor$vhod==vh$vhod),];
#kol_v=kol_v+1;vh$vhod=kol_v;vib$vhod=kol_v;vh$name='week';
#vhod=rbind(vhod,vh);vibor=rbind(vibor,vib)

vhod[(vhod$vid=='y'),'name']='kp'
neir$sozd$vhod=vhod;neir$sozd$vibor=vibor;
m=nrow(vhod[(vhod$vid=='m'),])
neir$k$x=kol_v-m;neir$k$m=m;




#собственно подготовка данных, пока без оптимизации процесса подготовки
itog=myPackage$trs.sozd_neir_dann(dannie,neir);dann=itog$dann;neir=itog$neir;rm(itog)

#нормированние и массивы по новому, и инициализация всех параметров нейросети по необходимости
dann_n=neural$normir_dann(neir,dann);
neir=dann_n$neir;ddd=dann_n$dd;dd_all=dann_n$dd_all;rm(dann_n);


rebro=neir$rebro;rebro[((rebro[,1]==-1)&(rebro[,3]==1)),3]=2;neir$rebro=rebro;


#настройка нейросети
#system.time(nastr<-   neural$neir_nastr(ddd,neir,10))
system.time(neir<-neural$neir_nastr_new(ddd,neir,1))
sigma=neir$k$sigma;
#  neir$k$ogr_k=0.2

progn=neural$neir_prognoz(dd_all,neir);dd_prog=dd_all;dd_prog$z=progn$z;dd_prog$zp=progn$zp;
#dd_prog=subset(dd_prog, select = c(Train,Date,Type,Seats,y,z,zp));
#подсчёт итоговых отличий, независимой сверкой
zz=aggregate(x =list(err= (dd_prog$y-dd_prog$z)**2,col=1),by = list(dd_prog$dann,dd_prog$Train), FUN = "sum")
zz$sigma=(zz$err/zz$col)**0.5; #получилось хорошо - совпадает!
#график коррелляции 
plot (x=dd_prog$y,y=dd_prog$z,col=dd_prog$dann)


#запись нейросети в базу истории нейросети, и полную и сокращённую
neir=neural$neir.save_to_hist(neir,NULL);#запись без прогнозов - не ставит глухую активность!


}}














  
  
#прибавить к нейросети входов! Случайным образом. И сразу и данные
#   min_before=10
itog=myPackage$trs.neir_plus_vhod(dannie,neir,min_before) 
dann=itog$dann;neir=itog$neir;rm(itog)

#нормированние и массивы по новому, и инициализация всех параметров нейросети по необходимости
dann_n=neural$normir_dann(neir,dann);
neir=dann_n$neir;ddd=dann_n$dd;dd_all=dann_n$dd_all;rm(dann_n);






##СОЗДАНИЕ МНОЖЕСТВА НЕЙРОСЕТЕЙ НУЖНЫМ МНЕ СПОСОБОМ
prognozi=c('kp','kp.Napr','kol_mest','kol_mest.Napr')
befores=10+(0:10)*3
#создание множества однотипных нейросетей с разными прогнозами и запаздываниями
myPackage$trs.sozd_neir_many(dannie,befores,prognozi) 





#по номеру нейросети возвращает из памяти саму нейросеть
neir=neural$get_neir_id(6)
#  neir$sozd$vhod     neir$rebro
  
#собственно подготовка данных, пока без оптимизации процесса подготовки
itog=myPackage$trs.sozd_neir_dann(dannie,neir);dann=itog$dann;neir=itog$neir;rm(itog)

#нормированние и массивы по новому, и инициализация всех параметров нейросети по необходимости
dann_n=neural$normir_dann(neir,dann);
neir=dann_n$neir;ddd=dann_n$dd;dd_all=dann_n$dd_all;rm(dann_n);


#поиск нужного номера
neir_hist_s=myPackage$trs.dann_load('neiroset','sokr') #чтение списка всех нейросетей
neir_hist_s=neir_hist_s[(neir_hist_s$activ==1),] #подвыборка активных

#ГЛАВНОЕ - АНАЛИЗ ПРОГНОЗОВ. ТАБЛИЦА ИТОГОВЫХ ПРОГНОЗОВ - ПО НОВОМУ
#     prover=c(30,50,100);     name='sahalin'
prognoz_itogi=neural$prognoz_itogi_new(name,prover=c(30,50,100))

#ДООБУЧЕНИЕ ВСЕХ НЕЙРОСЕТЕЙ многократно
vibor=data.frame(name='strela')
neural$all_neir_new_podnastr_many(dannie,120,vibor,5,razmnog=FALSE) 


#ДООБУЧЕНИЕ ВСЕХ НЕЙРОСЕТЕЙ - В ПАРАЛЛЕЛЬНОМ РЕЖИМЕ
vibor=data.frame(name='strela')
neural$all_neir_new_podnastr_parallel(dannie,60,vibor,2,razmnog=FALSE) 














#итоговые прогнозы все сразу
shema=myPackage$trs.shema_dannih();
progn=myPackage$trs.dann_load('progn','poln') #чтение списка всех нейросетей
plot (x=progn$Total,y=progn$progn,col=progn$id)



#поиск нужного номера
neir_hist_s=myPackage$trs.dann_load('neiroset','sokr') #чтение списка всех нейросетей
neir_hist_s=neir_hist_s[(neir_hist_s$activ==1),] #подвыборка активных

#   neir_hist_s[((neir_hist_s$id==25)&(neir_hist_s$activ==1)),'activ']=2
#  myPackage$trs.Data_save(neir_hist_s,'neiroset','sokr',TRUE)  #запись сокращений нейросетей обратно






#история одной нейросети
idd=171
neir_hist_s=myPackage$trs.dann_load('neiroset','sokr') #чтение списка всех нейросетей
neir_hist_s[is.na(neir_hist_s$pred_id),'pred_id']=0
hist=neir_hist_s[(neir_hist_s$id==idd),]
idd=unique(hist$pred_id)
while(idd>0){
  hist_=neir_hist_s[(neir_hist_s$id==idd),];
  hist=rbind(hist,hist_);
  idd=as.integer(unique(hist_$pred_id))
  }






#прогноз за дату на печать, и на график
prognoz_itogi=neural$prognoz_itogi_new(name,prover=c(30,50,100))

progn=prognoz_itogi[(prognoz_itogi$Date=='2015-10-15'),]
progn=progn[order(progn$Train,progn$Type,progn$id,progn$Seats),]

dbPath='d:/prognoz.txt'
 write.csv(x = progn, file = dbPath) 
 
pr=progn[(progn$Train=='0002Э'),]

plot (x=progn$Seats,y=progn$progn, col=progn$Napr)
plot (x=pr$Seats,y=pr$progn)












#по номеру нейросети возвращает из памяти саму нейросеть
neir=neural$get_neir_id(651)

#собственно подготовка данных, пока без оптимизации процесса подготовки
itog=myPackage$trs.sozd_neir_dann(dannie,neir);dann=itog$dann;neir=itog$neir;rm(itog)

#нормированние и массивы по новому, и инициализация всех параметров нейросети по необходимости
dann_n=neural$normir_dann(neir,dann);
neir=dann_n$neir;ddd=dann_n$dd;dd_all=dann_n$dd_all;rm(dann_n);



#настройка нейросети
#system.time(nastr<-   neural$neir_nastr(ddd,neir,10))
system.time(neir<-neural$neir_nastr_new(ddd,neir,30))
sigma=neir$k$sigma;
#  neir$k$ogr_k=0.2

progn=neural$neir_prognoz(dd_all,neir);dd_prog=dd_all;dd_prog$z=progn$z;dd_prog$zp=progn$zp;
#dd_prog=subset(dd_prog, select = c(Train,Date,Type,Seats,y,z,zp));
#подсчёт итоговых отличий, независимой сверкой
zz=aggregate(x =list(err= (dd_prog$y-dd_prog$z)**2,col=1),by = list(dd_prog$dann,dd_prog$Train), FUN = "sum")
zz$sigma=(zz$err/zz$col)**0.5; #получилось хорошо - совпадает!
#график коррелляции 
plot (x=dd_prog$y,y=dd_prog$z,col=dd_prog$dann)


#запись нейросети в базу истории нейросети, и полную и сокращённую
neir=neural$neir.save_to_hist(neir,NULL);#запись без прогнозов - не ставит глухую активность!

neir=neural$neir.save_to_hist(neir,dd_all);#запись с прогнозами



neir=neural$neir_ispravl(neir,ddd) #ИСПРАВЛЕНИЕ НЕЙРОСЕТИ - ЛИШНИЕ НЕЙРОНы ПРЕОБРАЗОВАТЬ

#поиск диапазонов значений входов внутренних нейронов
rezz=neural$neir_vnutri(neir,ddd)


#   neir$sozd$vhod









##############################################################################
#РАЗЛИЧНЫЕ ГРАФИКИ ДЛЯ ОТЧЁТА ПЕРВИЧНОГО

dn=dannie$rez_dann1;dn=dn[(!is.na(dn$zn0)),];dn$Napr=dn$Napr+1
dn=dn[(dn$Type=='К'),];dn$Date=as.Date(dn$Date)

zn=dn[(dn$name=='stoim'),];k=10000;k2=0
zn=dn[(dn$name=='kp'),];k=1;k2=0
#zn=dn[(dn$name=='cena'),];k=10000;k2=0

zn=zn[((zn$Date<='2015-09-30')&(zn$Date>='2015-09-01')),]

#zn=zn[(zn$Date=='2015-09-11'),]

cc=NULL
for (i in 0:(44-k2)){
  cn=zn;cn$zz=(cn[,paste('zn',i,sep='')])/k;
  if(k2==1){cn=zn;cn$zz=(cn[,paste('zn',i,sep='')]-cn[,paste('zn',i+1,sep='')]*k2)/k;}
  
  cn=subset(cn,select=c('Date','Napr','zz'));cn$i=i;
  cc=myPackage$sliv(cc,cn);}

plot (y=cc$zz,x=cc$i,col=cc$Napr)









dd=dn[((dn$Date<='2015-09-13')&(dn$Date>='2015-09-11')),]
dd=subset(dd,select=c(Date,Napr,zn0,name))
kp=dd[(dd$name=='kp'),];kp$kp=kp$zn0;
st=dd[(dd$name=='stoim'),];st$st=st$zn0
cen=merge(kp,st,by=c('Date','Napr'))
cen$cen=cen$st/cen$kp
plot (y=cen$cen,x=cen$Date,col=cen$Napr)

;









kp=dn[(dn$name=='kp'),]

kp=dn[(dn$name=='stoim'),]
kp=kp[((as.Date(kp$Date)<='2015-09-20')&(as.Date(kp$Date)>='2015-09-14')),]
kp=kp[(kp$Type=='К'),]

cc=NULL
for (i in 0:43){
  cn=kp;cn$zz=cn[,paste('zn',i,sep='')];cn$zz_=cn[,paste('zn',i,sep='')]-cn[,paste('zn',i+1,sep='')];
  cn$Napr=cn$Napr+1
  cn=subset(cn,select=c('Date','Napr','zz','zz_'));cn$i=i;
  cc=myPackage$sliv(cc,cn);}


cc_=cc[(cc$Napr==2),]
plot (y=cc_$zz,x=cc_$i)
      ,col=cc$Napr)



plot (y=cc$zz_,x=cc$i,col=cc$Napr)









kp=dn[(dn$name=='kp'),]
kp=kp[((as.Date(kp$Date)<='2015-09-30')&(as.Date(kp$Date)>='2015-09-01')),]
kp=kp[(kp$Type=='К'),]

kp$Napr=kp$Napr+1
kp_=subset(kp,select=c('Date','Napr','zn0'))
kp_$Date_=substr(as.character(kp_$Date),9,10)
kp_=kp_[order(kp_$Napr,kp_$Date_),]
plot (y=kp_$zn0,x=kp_$Date_,col=kp_$Napr, type="l")

? plot


















dn=dannie$rez_dann2;

dn=dn[(dn$Type=='К'),]


km=dn[(dn$name=='kol_mest'),]
ss=dn[(dn$name=='Seats'),]

km$mest=km$zn;ss$seat=ss$zn;
km$zn=NULL;ss$zn=NULL
ss=subset(ss,select=c('Date','Train','seat'))
ss=aggregate(x=list(seat=ss$seat),by=subset(ss,select=c('Date','Train')),FUN='min')


ff=merge(km,ss,by=c('Date','Train'))



plot (y=ff$seat,x=ff$Date)
plot (y=ff$mest,x=ff$Date)








##########################################################################
#статистика самых исходных данных

dann <- myPackage$trs.dann_load(name,'pas') #чтение всех уже накопленных данных
dann$Date=as.Date(dann$Date)

dn=dann[((dann$Date>='2015-09-01')&(dann$Date>='2015-09-01')&(dann$Type=='К')),]

dn$Cena=round(dn$Cena/1000)*100
dn$Stoim=dn$Stoim/10000


dd=aggregate(x=subset(dn,select=c(Stoim,Kol_pas)),by=subset(dn,select=c(Cena)),FUN='sum')
dd=dd[(dd$Cena>0),]

plot (y=dd$Stoim, x=dd$Cena)
plot (y=dd$Kol_pas, x=dd$Cena)

dd$ed=1
dd_=dd;dd_$cen=dd_$Cena;dd_$st=dd_$Stoim;
dd_=subset(dd_, select=c('cen','ed','st'))

dd_=merge(dd,dd_,by=c('ed'))
dd_=dd_[(dd_$cen<=dd_$Cena),]
dd_=aggregate(x=subset(dd_,select=c(st)),by=subset(dd_,select=c(Cena)),FUN='sum')
plot (y=dd_$st, x=dd_$Cena)
st=max(dd_$st)
dd_$k=0
dd_[((dd_$st>st*0.05)&(dd_$st<st*0.95)),'k']=1
dd_$pr=round(1000*dd_$st/st)/10













######################################################################################
#получение прогнозов на конкретный рейс. и оптимизация цены


#подготовлены данные для случайной выборки



#по номеру нейросети возвращает из памяти саму нейросеть
neir=neural$get_neir_id(31)

#собственно подготовка данных, пока без оптимизации процесса подготовки
itog=myPackage$trs.sozd_neir_dann(dannie,neir);dann=itog$dann;neir=itog$neir;rm(itog)


#подготовка данных перебора вариантов
vhod=neir$sozd$vhod
vh=vhod[((vhod$name!='cena')&(vhod$vid=='x')&(vhod$bef_otp>0)),]
before=min(vh$bef_otp)
vh=vhod[((vhod$name=='cena')&(vhod$vid=='x')&(vhod$bef_otp<before)),]

dn=dann[((dann$Date>='2015-09-07')&(dann$Date<='2015-09-13')),];dn$cen=NA;dd=dn;
dn=dann[(dann$Date=='2015-09-11'),];dn$cen=NA;dd=dn;dann=dn;

for (cc in (0:100)/10){dd$cen=cc;
  for (vhod in vh$vhod){dd[,paste('x',vhod,sep='.')]=cc};dann=rbind(dann,dd)}
rm(dd,cc,vhod,before)



#нормированние и массивы по новому, и инициализация всех параметров нейросети по необходимости
dann_n=neural$normir_dann(neir,dann);
neir=dann_n$neir;ddd=dann_n$dd;dd_all=dann_n$dd_all;rm(dann_n);

#    neir$sozd$vhod

# rebro=neir$rebro;rebro[((rebro[,1]==-1)&(rebro[,3]==1)),3]=2;neir$rebro=rebro;


#настройка нейросети
#system.time(nastr<-   neural$neir_nastr(ddd,neir,10))
#system.time(neir<-neural$neir_nastr_new(ddd,neir,60))
sigma=neir$k$sigma;
#  neir$k$ogr_k=0.2

progn=neural$neir_prognoz(dd_all,neir);dd_prog=dd_all;dd_prog$z=progn$z;dd_prog$zp=progn$zp;
dd_prog$napr=dd_prog$Napr+1
dd_prog=subset(dd_prog,select=c(napr,cen,z,y,x.9));
dd_prog$st=dd_prog$cen*(dd_prog$z-dd_prog$x.9)

plot (y=dd_prog$z,x=dd_prog$cen,col=dd_prog$napr)

plot (y=dd_prog$st,x=dd_prog$cen,col=dd_prog$napr)


















name='sahalin'
name='strela'

#ПАССАЖИРЫ запуск сбора данных. по фильтру Сахалин - месячные данные
myPackage$trs.pData.aggregate(name)




#ПАССАЖИРЫ  апдейт суточными данными
myPackage$trs.pData.update(name);




shema=myPackage$trs.shema_dannih()





source('./scripts/passengers.r');
source('./scripts/trainset.r');

source('./scripts/neural.r');
source('./scripts/neural2.r');















